from __future__ import annotations

import json
import hashlib
import math
import re
import sys
import threading
import xml.etree.ElementTree as ET
from collections import defaultdict
from datetime import datetime
from functools import lru_cache
from importlib import resources
from pathlib import Path
from typing import Any, Callable, Iterable

from PIL import Image, ImageColor, ImageDraw, ImageOps
from PyQt6.QtCore import QEvent, QPoint, QPointF, QRect, QRectF, Qt, QTimer, pyqtSignal
from PyQt6.QtGui import (
    QAction,
    QColor,
    QCursor,
    QFontDatabase,
    QGuiApplication,
    QIcon,
    QImage,
    QKeySequence,
    QLinearGradient,
    QPainter,
    QPainterPath,
    QPalette,
    QPen,
    QPixmap,
)
from PyQt6.QtWidgets import (
    QAbstractItemView,
    QApplication,
    QCheckBox,
    QComboBox,
    QDialog,
    QDoubleSpinBox,
    QFileDialog,
    QFormLayout,
    QFrame,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QInputDialog,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMainWindow,
    QMenu,
    QMessageBox,
    QPushButton,
    QHeaderView,
    QScrollArea,
    QSlider,
    QSplitter,
    QSpinBox,
    QTreeWidget,
    QTreeWidgetItem,
    QVBoxLayout,
    QWidget,
    QColorDialog,
)

from app_common.about_dialog import load_about_info, load_about_images, show_about_dialog
from app_common.app_info_bar import AppInfoBar
from app_common.log import get_logger
from app_common.send_to_app import SingleInstanceReceiver

import birdstamp
from birdstamp.config import get_config_path
from birdstamp.constants import SEND_TO_APP_ID, SUPPORTED_EXTENSIONS
from birdstamp.decoders.image_decoder import decode_image
from birdstamp.discover import discover_inputs
from app_common.exif_io import (
    extract_many,
    extract_pillow_metadata,
    extract_metadata_with_xmp_priority,
    read_batch_metadata,
)
from birdstamp.meta.normalize import format_settings_line, normalize_metadata
from birdstamp.render.typography import list_available_font_paths, load_font

from birdstamp.gui import editor_core
from birdstamp.gui import editor_options
from birdstamp.gui import editor_template
from birdstamp.gui import editor_utils
from birdstamp.gui import template_context as _template_context
from birdstamp.gui.editor_template_dialog import (
    _CropPaddingEditorWidget,
    _GradientBarWidget,  # noqa: F401  (re-exported for compat)
    _GradientEditorWidget,  # noqa: F401
    TemplateManagerDialog,
)
from app_common.preview_canvas import PreviewWithStatusBar
from birdstamp.gui.editor_preview_canvas import EditorPreviewCanvas, EditorPreviewOverlayState
from birdstamp.gui.editor_photo_list import (
    PHOTO_COL_CAPTURE_TIME,
    PHOTO_COL_NAME,
    PHOTO_COL_RATING,
    PHOTO_COL_RATIO,
    PHOTO_COL_ROW,
    PHOTO_COL_TITLE,
    PHOTO_LIST_PHOTO_INFO_ROLE,
    PHOTO_LIST_PATH_ROLE,
    PHOTO_LIST_SEQUENCE_ROLE,
    PHOTO_LIST_SORT_ROLE,
    PhotoListItem,
    PhotoListWidget,
)
from birdstamp.gui.editor_crop_calculator import _BirdStampCropMixin
from birdstamp.gui.editor_renderer import _BirdStampRendererMixin
from birdstamp.gui.editor_exporter import _BirdStampExporterMixin
from app_common.report_db import ReportDB, resolve_existing_report_db_path

# Re-export / aliases for refactored symbols (used below)
ALIGN_OPTIONS_VERTICAL = editor_utils.ALIGN_OPTIONS_VERTICAL
ALIGN_OPTIONS_HORIZONTAL = editor_utils.ALIGN_OPTIONS_HORIZONTAL
STYLE_OPTIONS = editor_options.STYLE_OPTIONS
RATIO_OPTIONS = editor_options.RATIO_OPTIONS
MAX_LONG_EDGE_OPTIONS = editor_options.MAX_LONG_EDGE_OPTIONS
OUTPUT_FORMAT_OPTIONS = editor_options.OUTPUT_FORMAT_OPTIONS
COLOR_PRESETS = editor_options.COLOR_PRESETS
DEFAULT_FIELD_TAG = editor_options.DEFAULT_FIELD_TAG
TAG_OPTIONS = editor_options.TAG_OPTIONS
SAMPLE_RAW_METADATA = editor_options.SAMPLE_RAW_METADATA
_DEFAULT_CROP_EFFECT_ALPHA = editor_utils.DEFAULT_CROP_EFFECT_ALPHA
_DEFAULT_CROP_PADDING_PX = editor_core.DEFAULT_CROP_PADDING_PX
_CENTER_MODE_IMAGE = editor_core.CENTER_MODE_IMAGE
_CENTER_MODE_FOCUS = editor_core.CENTER_MODE_FOCUS
_CENTER_MODE_BIRD = editor_core.CENTER_MODE_BIRD
_CENTER_MODE_OPTIONS = editor_core.CENTER_MODE_OPTIONS
_DEFAULT_TEMPLATE_BANNER_COLOR = editor_utils.DEFAULT_TEMPLATE_BANNER_COLOR
_TEMPLATE_BANNER_COLOR_NONE = editor_utils.TEMPLATE_BANNER_COLOR_NONE
_TEMPLATE_BANNER_COLOR_CUSTOM = editor_utils.TEMPLATE_BANNER_COLOR_CUSTOM
_TEMPLATE_BANNER_TOP_PADDING_PX = editor_utils.TEMPLATE_BANNER_TOP_PADDING_PX
_build_color_preview_swatch = editor_utils.build_color_preview_swatch
_set_color_preview_swatch = editor_utils.set_color_preview_swatch
_configure_form_layout = editor_utils.configure_form_layout
_normalize_template_banner_color = editor_utils.normalize_template_banner_color
_template_banner_fill_color = editor_utils.template_banner_fill_color
_template_font_choices = editor_utils.template_font_choices
_template_font_path_from_type = editor_utils.template_font_path_from_type
_font_family_label_from_path = editor_utils.font_family_label_from_path
_start_screen_color_picker = editor_utils.start_screen_color_picker
_build_placeholder_image = editor_utils.build_placeholder_image
_build_metadata_context = editor_utils.build_metadata_context
_BANNER_BACKGROUND_STYLE_SOLID = editor_template.BANNER_BACKGROUND_STYLE_SOLID
_BANNER_BACKGROUND_STYLE_GRADIENT_BOTTOM = editor_template.BANNER_BACKGROUND_STYLE_GRADIENT_BOTTOM
_BANNER_BACKGROUND_STYLE_OPTIONS = editor_template.BANNER_BACKGROUND_STYLE_OPTIONS
_normalize_banner_background_style = editor_template.normalize_banner_background_style
_BANNER_GRADIENT_HEIGHT_PCT_DEFAULT = editor_template.BANNER_GRADIENT_HEIGHT_PCT_DEFAULT
_BANNER_GRADIENT_HEIGHT_PCT_MIN = editor_template.BANNER_GRADIENT_HEIGHT_PCT_MIN
_BANNER_GRADIENT_HEIGHT_PCT_MAX = editor_template.BANNER_GRADIENT_HEIGHT_PCT_MAX
_BANNER_GRADIENT_BOTTOM_OPACITY_PCT_DEFAULT = editor_template.BANNER_GRADIENT_BOTTOM_OPACITY_PCT_DEFAULT
_BANNER_GRADIENT_BOTTOM_OPACITY_PCT_MIN = editor_template.BANNER_GRADIENT_BOTTOM_OPACITY_PCT_MIN
_BANNER_GRADIENT_BOTTOM_OPACITY_PCT_MAX = editor_template.BANNER_GRADIENT_BOTTOM_OPACITY_PCT_MAX
_BANNER_GRADIENT_TOP_OPACITY_PCT_DEFAULT = editor_template.BANNER_GRADIENT_TOP_OPACITY_PCT_DEFAULT
_BANNER_GRADIENT_TOP_COLOR_DEFAULT = editor_template.BANNER_GRADIENT_TOP_COLOR_DEFAULT
_BANNER_GRADIENT_BOTTOM_COLOR_DEFAULT = editor_template.BANNER_GRADIENT_BOTTOM_COLOR_DEFAULT
_DEFAULT_TEMPLATE_CENTER_MODE = editor_template.DEFAULT_TEMPLATE_CENTER_MODE
_DEFAULT_TEMPLATE_MAX_LONG_EDGE = editor_template.DEFAULT_TEMPLATE_MAX_LONG_EDGE
_path_key = editor_utils.path_key
_sanitize_template_name = editor_utils.sanitize_template_name
_template_directory = editor_template.template_directory
_ensure_template_repository = editor_template.ensure_template_repository
_list_template_names = editor_template.list_template_names
_load_template_payload = editor_template.load_template_payload
_save_template_payload = editor_template.save_template_payload
_default_template_payload = editor_template.default_template_payload
_normalize_template_payload = editor_template.normalize_template_payload
render_template_overlay = editor_template.render_template_overlay
_render_template_overlay_in_crop_region = editor_template.render_template_overlay_in_crop_region
_extract_focus_box = editor_core.extract_focus_box
_extract_focus_point = editor_core.get_focus_point
_transform_focus_box_after_crop = editor_core.transform_focus_box_after_crop
_normalized_box_to_pixel_box = editor_core.normalized_box_to_pixel_box
_transform_source_box_after_crop_padding = editor_core.transform_source_box_after_crop_padding
_resize_fit = editor_core.resize_fit
_pad_image = editor_core.pad_image
_parse_ratio_value = editor_core.parse_ratio_value
_parse_bool_value = editor_core.parse_bool_value
_parse_padding_value = editor_core.parse_padding_value
_expand_unit_box_to_unclamped_pixels = editor_core.expand_unit_box_to_unclamped_pixels
_normalize_center_mode = editor_core.normalize_center_mode
_normalize_unit_box = editor_core.normalize_unit_box
_box_center = editor_core.box_center
_solve_axis_crop_start = editor_core.solve_axis_crop_start
_compute_ratio_crop_box = editor_core.compute_ratio_crop_box
_crop_box_has_effect = editor_core.crop_box_has_effect
_crop_image_by_normalized_box = editor_core.crop_image_by_normalized_box
_detect_primary_bird_box = editor_core.detect_primary_bird_box
_load_sidecar_xmp_metadata = editor_core.load_sidecar_xmp_metadata
_load_bird_detector = editor_core.preload_bird_detector
_crop_to_ratio_with_anchor = editor_core.crop_to_ratio_with_anchor
_clean_text = editor_core.clean_text
_normalize_lookup = editor_core.normalize_lookup
_safe_color = editor_utils.safe_color
_DEFAULT_TEMPLATE_FONT_TYPE = editor_utils.DEFAULT_TEMPLATE_FONT_TYPE
_normalize_template_font_type = editor_utils.normalize_template_font_type
_normalize_template_field = editor_template.normalize_template_field
_deep_copy_payload = editor_template.deep_copy_payload


class _ReportDBListWidget(QListWidget):
    """支持拖放 report.db 文件的列表控件。"""

    def __init__(self, owner, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self._owner = owner
        self.setAcceptDrops(True)

    def dragEnterEvent(self, event) -> None:  # type: ignore[override]
        if event.mimeData() and event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dragMoveEvent(self, event) -> None:  # type: ignore[override]
        if event.mimeData() and event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dropEvent(self, event) -> None:  # type: ignore[override]
        mime = event.mimeData()
        if not mime or not mime.hasUrls():
            event.ignore()
            return
        paths: list[Path] = []
        for url in mime.urls():
            try:
                if url.isLocalFile():
                    paths.append(Path(url.toLocalFile()))
            except Exception:
                continue
        if paths and hasattr(self._owner, "_add_report_db_paths"):
            try:
                self._owner._add_report_db_paths(paths)
            except Exception:
                pass
        event.acceptProposedAction()


def _app_icon_paths() -> tuple[Path, Path]:
    """返回 (窗口用图标路径, AppInfoBar 用 PNG 路径)。窗口优先 .ico/.icns，否则 .png。"""
    try:
        with resources.as_file(resources.files("birdstamp.gui") / "resources") as res:
            icon_dir = Path(res)
    except Exception:
        icon_dir = Path(__file__).resolve().parent / "resources"
    png_path = icon_dir / "app_icon.png"
    ico_path = icon_dir / "app_icon.ico"
    icns_path = icon_dir / "app_icon.icns"
    if sys.platform == "win32" and ico_path.exists():
        window_icon = ico_path
    elif sys.platform == "darwin" and icns_path.exists():
        window_icon = icns_path
    else:
        window_icon = png_path
    return (window_icon, png_path if png_path.exists() else window_icon)


def _get_bird_detector_error_message() -> str:
    return editor_core.get_bird_detector_error_message()


_pil_to_qpixmap = editor_utils.pil_to_qpixmap
_log = get_logger("editor")


# PreviewCanvas and PhotoListWidget now live in editor_preview_canvas.py / editor_photo_list.py

class BirdStampEditorWindow(QMainWindow, _BirdStampCropMixin, _BirdStampRendererMixin, _BirdStampExporterMixin):
    def __init__(
        self,
        startup_file: Path | None = None,
        startup_files: list[Path] | None = None,
    ) -> None:
        super().__init__()
        self.setWindowTitle("极速鸟框")
        self.resize(1420, 920)
        self.setMinimumSize(1120, 720)

        self.template_dir = _template_directory()
        _ensure_template_repository(self.template_dir)

        self.template_paths: dict[str, Path] = {}
        self.current_template_payload: dict[str, Any] = _default_template_payload(name="default")

        # ReportDB 相关：多库列表 + 行缓存（stem → row）
        self._report_db_entries: list[Path] = []
        self._report_db_cache: dict[str, dict[str, Any]] = {}

        self.preview_pixmap: QPixmap | None = None
        self.preview_overlay_state = EditorPreviewOverlayState()
        self._original_mode_pixmap: QPixmap | None = None
        self._original_mode_signature: str | None = None
        self._bird_box_cache: dict[str, tuple[float, float, float, float] | None] = {}
        self.photo_render_overrides: dict[str, dict[str, Any]] = {}
        self._bird_detect_error_reported = False
        self._bird_detector_preload_started = False
        self._bird_detector_preload_thread: threading.Thread | None = None
        self.last_rendered: Image.Image | None = None
        self.current_path: Path | None = None
        self.current_photo_info: _template_context.PhotoInfo | None = None
        self.current_source_image: Image.Image | None = None
        self.current_raw_metadata: dict[str, Any] = {}
        self.current_metadata_context: dict[str, str] = {}
        self.raw_metadata_cache: dict[str, dict[str, Any]] = {}
        self._pending_preview_fit_reset: bool = False
        # 占位图路径标记：非 None 时表示当前预览的是默认占位图而非用户照片
        self.placeholder_path: Path | None = None

        self.placeholder = _build_placeholder_image(1400, 900)

        self._preview_debounce_timer = QTimer(self)
        self._preview_debounce_timer.setSingleShot(True)
        self._preview_debounce_timer.setInterval(250)
        self._preview_debounce_timer.timeout.connect(self.render_preview)

        self._setup_ui()
        self._setup_shortcuts()
        self._apply_system_adaptive_style()
        self._reload_template_combo(preferred="default")
        self._set_status("就绪。请添加照片并选择模板。")
        self._show_placeholder_preview()
        self._start_bird_detector_preload()

        # 冷启动或「发送到本应用」传入的文件列表：加入照片列表
        files_to_add: list[Path] = []
        if startup_files:
            files_to_add = list(startup_files)
        elif startup_file:
            files_to_add = [startup_file]
        if files_to_add:
            self._add_photo_paths(files_to_add)

        # 初始化 report.db 行解析器（无缓存时返回 None）
        self._update_report_db_row_resolver()

    # ------------------------------------------------------------------
    # ReportDB 列表与缓存
    # ------------------------------------------------------------------

    def _update_report_db_row_resolver(self) -> None:
        """根据当前缓存更新模板上下文中的 report.db 行解析函数。"""

        cache = self._report_db_cache

        if not cache:
            _template_context.set_report_db_row_resolver(None)
            return

        def _resolver(path: Path) -> dict[str, Any] | None:
            for key in _template_context.report_db_lookup_keys_for_path(path):
                row = cache.get(key)
                if isinstance(row, dict):
                    return row
            return None

        _template_context.set_report_db_row_resolver(_resolver)

    def _rebuild_report_db_cache(self) -> None:
        """根据当前 report.db 列表重建行缓存，并更新 provider 解析器。"""
        cache: dict[str, dict[str, Any]] = {}
        for db_path in self._report_db_entries:
            try:
                p = db_path
            except Exception:
                continue
            try:
                db = ReportDB.open_db_path_if_exists(str(p))
            except Exception:
                continue
            if not db:
                continue
            try:
                for row in db.get_all_photos():
                    row_data = dict(row)
                    try:
                        lookup_keys = _template_context.report_db_lookup_keys_for_value(row_data.get("filename"))
                    except Exception:
                        continue
                    if not lookup_keys:
                        continue
                    for key in lookup_keys:
                        if key in cache:
                            continue
                        cache[key] = row_data
            finally:
                try:
                    db.close()
                except Exception:
                    pass
        self._report_db_cache = cache
        self._update_report_db_row_resolver()

    def _add_report_db_paths(self, paths: Iterable[Path]) -> None:
        """将一个或多个 report.db 文件路径加入列表并重建缓存。"""
        added = 0
        existing: set[Path] = set(self._report_db_entries)
        for incoming in paths:
            try:
                p = incoming if isinstance(incoming, Path) else Path(str(incoming))
            except Exception:
                continue
            try:
                p = p.resolve(strict=False)
            except Exception:
                pass
            if not p.is_file():
                continue
            name_lower = p.name.lower()
            if not (name_lower.endswith(".db") or name_lower == "report.db"):
                continue
            if p in existing:
                continue
            existing.add(p)
            self._report_db_entries.append(p)
            label = f"{p.parent.name} ({p.name})"
            item = QListWidgetItem(label)
            item.setData(Qt.ItemDataRole.UserRole, str(p))
            self.report_db_list.addItem(item)
            added += 1
        if added:
            self._rebuild_report_db_cache()

    def _auto_add_report_db_paths_for_photos(self, paths: Iterable[Path]) -> int:
        """根据照片所在目录自动发现 report.db，并加入当前列表。"""
        existing_count = len(self._report_db_entries)
        candidates: list[Path] = []
        seen_dirs: set[Path] = set()
        for incoming in paths:
            try:
                photo_path = incoming if isinstance(incoming, Path) else Path(str(incoming))
                photo_path = photo_path.resolve(strict=False)
                parent = photo_path.parent
            except Exception:
                continue
            if parent in seen_dirs:
                continue
            seen_dirs.add(parent)
            db_path = resolve_existing_report_db_path(str(parent))
            if not db_path:
                continue
            try:
                candidates.append(Path(db_path))
            except Exception:
                continue
        if candidates:
            self._add_report_db_paths(candidates)
        return max(0, len(self._report_db_entries) - existing_count)

    def _remove_selected_report_dbs(self) -> None:
        """从列表中移除选中的 report.db，并更新缓存。"""
        items = self.report_db_list.selectedItems()
        if not items:
            return
        paths_to_remove: set[Path] = set()
        for item in items:
            raw = item.data(Qt.ItemDataRole.UserRole)
            if isinstance(raw, str):
                try:
                    paths_to_remove.add(Path(raw))
                except Exception:
                    pass
            row = self.report_db_list.row(item)
            if row >= 0:
                self.report_db_list.takeItem(row)
        if not paths_to_remove:
            return
        self._report_db_entries = [p for p in self._report_db_entries if p not in paths_to_remove]
        self._rebuild_report_db_cache()

    def _clear_report_dbs(self) -> None:
        """清空所有 report.db 记录与缓存。"""
        self.report_db_list.clear()
        self._report_db_entries.clear()
        self._report_db_cache.clear()
        self._update_report_db_row_resolver()

    def _setup_ui(self) -> None:
        root = QWidget()
        self.setCentralWidget(root)
        root_layout = QHBoxLayout(root)
        root_layout.setContentsMargins(10, 10, 10, 10)

        splitter = QSplitter(Qt.Orientation.Horizontal)
        root_layout.addWidget(splitter)

        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(8, 8, 8, 8)
        left_layout.setSpacing(8)

        _window_icon_path, _info_bar_icon_path = _app_icon_paths()
        _app_icon = QIcon(str(_window_icon_path))
        if not _app_icon.isNull():
            self.setWindowIcon(_app_icon)
        self._info_bar = AppInfoBar(
            self,
            title="极速鸟框",
            subtitle="自动裁切鸟类照片",
            icon_path=str(_info_bar_icon_path) if _info_bar_icon_path.exists() else None,
            on_about_clicked=self._show_about_dialog,
        )
        left_layout.addWidget(self._info_bar)

        self._setup_ui_photos_list(left_layout)
        self._setup_ui_template_output_actions(left_layout)

        right_panel = self._setup_ui_preview_panel()

        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 0)
        splitter.setStretchFactor(1, 1)
        splitter.setSizes([600, 920])
        splitter.setChildrenCollapsible(False)

        self.setStatusBar(self.statusBar())

    def _setup_ui_photos_list(self, left_layout: QVBoxLayout) -> None:
        """构建左侧「Report 数据库」+「照片列表」分组 UI。"""
        # ── Report 数据库列表 ────────────────────────────────────────────────
        db_group = QGroupBox("Report 数据库")
        db_layout = QVBoxLayout(db_group)
        db_layout.setSpacing(6)

        self.report_db_list = _ReportDBListWidget(self)
        self.report_db_list.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        row_h = self.report_db_list.fontMetrics().height() + 4
        self.report_db_list.setMaximumHeight(2 * row_h + 6)
        db_layout.addWidget(self.report_db_list, stretch=1)

        db_btn_row = QHBoxLayout()
        db_remove_btn = QPushButton("删除所选")
        db_remove_btn.clicked.connect(self._remove_selected_report_dbs)
        db_btn_row.addWidget(db_remove_btn)

        db_clear_btn = QPushButton("清空")
        db_clear_btn.clicked.connect(self._clear_report_dbs)
        db_btn_row.addWidget(db_clear_btn)
        db_btn_row.addStretch(1)
        db_layout.addLayout(db_btn_row)

        db_hint = QLabel("支持拖入 report.db 文件")
        db_hint.setStyleSheet("color: #7A7A7A; font-size: 11px;")
        db_layout.addWidget(db_hint)

        left_layout.addWidget(db_group)

        # ── 照片列表 ────────────────────────────────────────────────────────
        photos_group = QGroupBox("照片列表")
        photos_layout = QVBoxLayout(photos_group)
        photos_layout.setSpacing(6)

        photo_btn_row = QHBoxLayout()
        add_files_btn = QPushButton("添加照片")
        add_files_btn.clicked.connect(self._pick_files)
        photo_btn_row.addWidget(add_files_btn)

        add_dir_btn = QPushButton("添加目录")
        add_dir_btn.clicked.connect(self._pick_directory)
        photo_btn_row.addWidget(add_dir_btn)

        remove_btn = QPushButton("删除所选")
        remove_btn.clicked.connect(self._remove_selected_photos)
        photo_btn_row.addWidget(remove_btn)

        clear_btn = QPushButton("清空")
        clear_btn.clicked.connect(self._clear_photos)
        photo_btn_row.addWidget(clear_btn)
        photos_layout.addLayout(photo_btn_row)

        self.photo_list = PhotoListWidget()
        self.photo_list.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.photo_list.pathsDropped.connect(self._add_photo_paths)
        self.photo_list.currentItemChanged.connect(self._on_photo_selected)
        photos_layout.addWidget(self.photo_list, stretch=1)

        hint = QLabel("支持拖入单张照片或整个目录")
        hint.setStyleSheet("color: #7A7A7A;")
        photos_layout.addWidget(hint)

        left_layout.addWidget(photos_group, stretch=2)

    # ------------------------------------------------------------------
    # ReportDB 列表与缓存
    # ------------------------------------------------------------------

    def _update_report_db_row_resolver(self) -> None:
        """根据当前缓存更新模板上下文中的 report.db 行解析函数。"""

        cache = self._report_db_cache

        if not cache:
            _template_context.set_report_db_row_resolver(None)
            return

        def _resolver(path: Path) -> dict[str, Any] | None:
            for key in _template_context.report_db_lookup_keys_for_path(path):
                row = cache.get(key)
                if isinstance(row, dict):
                    return row
            return None

        _template_context.set_report_db_row_resolver(_resolver)

    def _setup_ui_template_output_actions(self, left_layout: QVBoxLayout) -> None:
        """构建左侧「模板」「模板选项重载」「操作」分组 UI。"""
        # ── 模板 ─────────────────────────────────────────────────────────────
        template_group = QGroupBox("模板")
        template_layout = QHBoxLayout(template_group)

        self.template_combo = QComboBox()
        self.template_combo.currentTextChanged.connect(self._on_template_changed)
        template_layout.addWidget(self.template_combo, stretch=1)

        manage_template_btn = QPushButton("模板管理")
        manage_template_btn.clicked.connect(self._open_template_manager)
        template_layout.addWidget(manage_template_btn)
        left_layout.addWidget(template_group)

        # ── 模板选项重载（可滚动） ─────────────────────────────────────────
        override_group = QGroupBox("模板选项重载")
        override_form = QFormLayout(override_group)
        _configure_form_layout(override_form)

        self.ratio_combo = QComboBox()
        for label, ratio in RATIO_OPTIONS:
            self.ratio_combo.addItem(label, ratio)
        self.ratio_combo.currentIndexChanged.connect(self._on_crop_settings_changed)
        override_form.addRow("裁切比例", self.ratio_combo)

        self.center_mode_combo = QComboBox()
        self.center_mode_combo.addItem("鸟体", _CENTER_MODE_BIRD)
        self.center_mode_combo.addItem("焦点", _CENTER_MODE_FOCUS)
        self.center_mode_combo.addItem("图像中心", _CENTER_MODE_IMAGE)
        self.center_mode_combo.currentIndexChanged.connect(self._on_crop_settings_changed)
        override_form.addRow("裁切中心", self.center_mode_combo)

        self._crop_padding_widget = _CropPaddingEditorWidget()
        self._crop_padding_widget.changed.connect(self._on_crop_settings_changed)
        # Backward-compat aliases used throughout the rest of the file
        self.crop_padding_top = self._crop_padding_widget.top_spin
        self.crop_padding_bottom = self._crop_padding_widget.bottom_spin
        self.crop_padding_left = self._crop_padding_widget.left_spin
        self.crop_padding_right = self._crop_padding_widget.right_spin
        self.crop_padding_top_slider = self._crop_padding_widget.top_slider
        self.crop_padding_bottom_slider = self._crop_padding_widget.bottom_slider
        self.crop_padding_left_slider = self._crop_padding_widget.left_slider
        self.crop_padding_right_slider = self._crop_padding_widget.right_slider
        self.crop_padding_fill_combo = self._crop_padding_widget.fill_combo
        self.crop_padding_fill_swatch = self._crop_padding_widget.fill_swatch
        override_form.addRow("边界填充 / 外圈颜色", self._crop_padding_widget)

        override_btn_row = QHBoxLayout()
        reset_override_btn = QPushButton("重置为模板值")
        reset_override_btn.setToolTip(
            "<b>重置为模板值</b><br>"
            "将「裁切比例」「裁切中心」「裁切策略」<br>"
            "「边界填充」「外圈颜色」等选项恢复为<br>"
            "当前所选模板中存储的默认值。<br>"
            "<i>适合撤销手动调整、快速回到模板初始状态。</i>"
        )
        reset_override_btn.clicked.connect(self._reset_template_overrides)
        override_btn_row.addWidget(reset_override_btn)
        self.apply_all_btn = QPushButton("全部应用")
        self.apply_all_btn.setToolTip(
            "<b>全部应用</b><br>"
            "将当前「模板选项重载」中的所有设置<br>"
            "批量覆盖到已加载的每张照片，<br>"
            "包括裁切比例、中心模式、策略、<br>"
            "边界填充及外圈颜色。<br>"
            "<i>仅影响本次会话的照片列表，不修改模板文件。</i>"
        )
        self.apply_all_btn.clicked.connect(self._apply_current_settings_to_all_photos)
        override_btn_row.addWidget(self.apply_all_btn)
        override_form.addRow("", override_btn_row)

        override_scroll = QScrollArea()
        override_scroll.setWidget(override_group)
        override_scroll.setWidgetResizable(True)
        override_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        override_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        override_scroll.setMinimumHeight(180)
        override_scroll.setFrameShape(QFrame.Shape.NoFrame)
        left_layout.addWidget(override_scroll)

        # ── 全局选项 + 操作（合并一组） ────────────────────────────────────
        actions_group = QGroupBox("操作")
        actions_root = QVBoxLayout(actions_group)
        actions_root.setSpacing(6)

        global_form = QFormLayout()
        global_form.setContentsMargins(0, 0, 0, 0)
        _configure_form_layout(global_form)

        self.output_format_combo = QComboBox()
        for suffix, label in OUTPUT_FORMAT_OPTIONS:
            self.output_format_combo.addItem(label, suffix)
        if self.output_format_combo.count() == 0:
            self.output_format_combo.addItem("PNG", "png")
            self.output_format_combo.addItem("JPG", "jpg")
        self.output_format_combo.currentIndexChanged.connect(self._on_output_settings_changed)
        global_form.addRow("输出格式", self.output_format_combo)

        self.draw_banner_check = QCheckBox("Banner 底")
        self.draw_banner_check.setChecked(True)
        self.draw_banner_check.toggled.connect(self._on_output_settings_changed)
        self.draw_text_check = QCheckBox("文本")
        self.draw_text_check.setChecked(True)
        self.draw_text_check.toggled.connect(self._on_output_settings_changed)
        overlay_row_widget = QWidget()
        overlay_row_layout = QHBoxLayout(overlay_row_widget)
        overlay_row_layout.setContentsMargins(0, 0, 0, 0)
        overlay_row_layout.setSpacing(10)
        overlay_row_layout.addWidget(self.draw_banner_check)
        overlay_row_layout.addWidget(self.draw_text_check)
        overlay_row_layout.addStretch()
        global_form.addRow("叠加信息", overlay_row_widget)

        self.max_edge_combo = QComboBox()
        seen_edges: set[int] = set()
        for value in MAX_LONG_EDGE_OPTIONS:
            try:
                edge = int(value)
            except Exception:
                continue
            if edge in seen_edges:
                continue
            seen_edges.add(edge)
            self.max_edge_combo.addItem("不限制" if edge <= 0 else str(edge), edge)
        if self.max_edge_combo.count() == 0:
            self.max_edge_combo.addItem("不限制", 0)
        self.max_edge_combo.setCurrentIndex(0)
        self.max_edge_combo.currentIndexChanged.connect(self._on_output_settings_changed)
        global_form.addRow("最大长边", self.max_edge_combo)

        actions_root.addLayout(global_form)

        export_btn_row = QHBoxLayout()
        export_btn_row.setSpacing(6)
        export_current_btn = QPushButton("导出当前")
        export_current_btn.clicked.connect(self.export_current)
        export_btn_row.addWidget(export_current_btn)
        export_batch_btn = QPushButton("批量导出")
        export_batch_btn.clicked.connect(self.export_all)
        export_btn_row.addWidget(export_batch_btn)
        actions_root.addLayout(export_btn_row)

        left_layout.addWidget(actions_group)
        left_layout.addStretch(1)

    def _setup_ui_preview_panel(self) -> QWidget:
        """构建右侧「预览区」UI，返回该面板 QWidget。"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(8, 8, 8, 8)
        right_layout.setSpacing(8)

        self.current_file_label = QLabel("当前照片: 未选择")
        right_layout.addWidget(self.current_file_label)

        preview_toolbar = QHBoxLayout()
        preview_toolbar.setContentsMargins(0, 0, 0, 0)
        preview_toolbar.setSpacing(8)

        self.show_crop_effect_check = QCheckBox("显示裁切效果")
        self.show_crop_effect_check.setChecked(True)
        self.show_crop_effect_check.toggled.connect(self._on_preview_toolbar_toggled)
        preview_toolbar.addWidget(self.show_crop_effect_check)

        self.crop_effect_alpha_label = QLabel("Alpha")
        preview_toolbar.addWidget(self.crop_effect_alpha_label)

        self.crop_effect_alpha_slider = QSlider(Qt.Orientation.Horizontal)
        self.crop_effect_alpha_slider.setRange(0, 255)
        self.crop_effect_alpha_slider.setSingleStep(1)
        self.crop_effect_alpha_slider.setPageStep(16)
        self.crop_effect_alpha_slider.setValue(_DEFAULT_CROP_EFFECT_ALPHA)
        self.crop_effect_alpha_slider.setFixedWidth(120)
        self.crop_effect_alpha_slider.valueChanged.connect(self._on_crop_effect_alpha_changed)
        preview_toolbar.addWidget(self.crop_effect_alpha_slider)

        self.crop_effect_alpha_value_label = QLabel(str(_DEFAULT_CROP_EFFECT_ALPHA))
        self.crop_effect_alpha_value_label.setMinimumWidth(28)
        preview_toolbar.addWidget(self.crop_effect_alpha_value_label)

        self.show_focus_box_check = QCheckBox("显示对焦点")
        self.show_focus_box_check.setChecked(True)
        self.show_focus_box_check.toggled.connect(self._on_preview_toolbar_toggled)
        preview_toolbar.addWidget(self.show_focus_box_check)

        self.show_bird_box_check = QCheckBox("显示鸟体框")
        self.show_bird_box_check.setChecked(True)
        self.show_bird_box_check.toggled.connect(self._on_preview_toolbar_toggled)
        preview_toolbar.addWidget(self.show_bird_box_check)
        preview_toolbar.addStretch(1)
        right_layout.addLayout(preview_toolbar)

        self.preview_label = PreviewWithStatusBar(canvas=EditorPreviewCanvas())
        self.preview_label.setObjectName("PreviewLabel")
        right_layout.addWidget(self.preview_label, stretch=1)

        return right_panel

    def _setup_shortcuts(self) -> None:
        action_add = QAction(self)
        action_add.setShortcut(QKeySequence.StandardKey.Open)
        action_add.triggered.connect(self._pick_files)
        self.addAction(action_add)

        action_preview = QAction(self)
        action_preview.setShortcut(QKeySequence("Ctrl+R"))
        action_preview.triggered.connect(self.render_preview)
        self.addAction(action_preview)

        action_export_current = QAction(self)
        action_export_current.setShortcut(QKeySequence("Ctrl+E"))
        action_export_current.triggered.connect(self.export_current)
        self.addAction(action_export_current)

        action_export_all = QAction(self)
        action_export_all.setShortcut(QKeySequence("Ctrl+Shift+E"))
        action_export_all.triggered.connect(self.export_all)
        self.addAction(action_export_all)

    def _apply_system_adaptive_style(self) -> None:
        palette = self.palette()
        window_color = palette.color(QPalette.ColorRole.Window)
        base_color = palette.color(QPalette.ColorRole.Base)
        text_color = palette.color(QPalette.ColorRole.Text)
        button_color = palette.color(QPalette.ColorRole.Button)
        button_text = palette.color(QPalette.ColorRole.ButtonText)
        disabled_text = palette.color(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text)

        dark_mode = window_color.lightness() < 128
        border_color = window_color.lighter(132) if dark_mode else window_color.darker(130)
        hover_color = button_color.lighter(115) if dark_mode else button_color.darker(105)
        preview_bg = window_color.lighter(108) if dark_mode else window_color.darker(103)

        self.setStyleSheet(
            f"""
            QWidget {{
                font-size: 13px;
            }}
            QGroupBox {{
                border: 1px solid {border_color.name()};
                border-radius: 10px;
                margin-top: 10px;
                background: {base_color.name()};
            }}
            QGroupBox::title {{
                left: 10px;
                padding: 0 4px;
                font-weight: 600;
            }}
            QLineEdit {{
                border: 1px solid {border_color.name()};
                border-radius: 7px;
                background: {base_color.name()};
                color: {text_color.name()};
                min-height: 28px;
            }}
            QLineEdit {{
                padding: 5px 8px;
            }}
            QComboBox QAbstractItemView {{
                background: {base_color.name()};
                color: {text_color.name()};
                border: 1px solid {border_color.name()};
                selection-background-color: {hover_color.name()};
                selection-color: {text_color.name()};
                outline: none;
            }}
            QListWidget, QTreeWidget {{
                border: 1px solid {border_color.name()};
                border-radius: 7px;
                background: {base_color.name()};
                color: {text_color.name()};
            }}
            QPushButton {{
                border: 1px solid {border_color.name()};
                border-radius: 7px;
                background: {button_color.name()};
                color: {button_text.name()};
                padding: 6px 10px;
            }}
            QPushButton:hover {{
                background: {hover_color.name()};
            }}
            QPushButton:disabled {{
                color: {disabled_text.name()};
            }}
            QLabel#PreviewLabel {{
                border: 1px solid {border_color.name()};
                border-radius: 10px;
                background: {preview_bg.name()};
                color: {text_color.name()};
            }}
            QLabel#PreviewInfoLabel {{
                color: {text_color.name()};
                padding: 2px 4px;
            }}
            """
        )

    def _set_status(self, message: str) -> None:
        self.statusBar().showMessage(message)

    def _show_error(self, title: str, message: str) -> None:
        QMessageBox.critical(self, title, message)

    def _show_about_dialog(self) -> None:
        override_path = get_config_path().parent / "about.cfg"
        override_str = str(override_path) if override_path.exists() else None
        # base_dir: 优先用工程根目录，使 about.cfg 中的相对图片路径（如 images/download.png）可正确解析
        import sys
        from pathlib import Path as _Path
        if getattr(sys, "frozen", False):
            base_dir = str(_Path(sys.executable).resolve().parent)
        else:
            base_dir = str(_Path(__file__).resolve().parent.parent.parent)
        about_info = load_about_info(
            override_path=override_str,
            app_name="极速鸟框",
            version=birdstamp.__version__,
        )
        about_images = load_about_images(override_path=override_str, base_dir=base_dir)
        show_about_dialog(self, about_info, logo_path=None, banner_path=None, images=about_images)

    def resizeEvent(self, event) -> None:  # type: ignore[override]
        super().resizeEvent(event)
        self._refresh_preview_label()

    def changeEvent(self, event) -> None:  # type: ignore[override]
        if event.type() in {QEvent.Type.PaletteChange, QEvent.Type.ApplicationPaletteChange}:
            self._apply_system_adaptive_style()
        super().changeEvent(event)

    def _on_preview_toolbar_toggled(self, _checked: bool) -> None:
        self._refresh_preview_label(preserve_view=True)

    def _on_preview_scale_mode_toggled(self, _checked: bool) -> None:
        self._refresh_preview_label(preserve_view=True)

    def _on_crop_effect_alpha_changed(self, value: int) -> None:
        alpha = max(0, min(255, int(value)))
        self.crop_effect_alpha_value_label.setText(str(alpha))
        self._apply_preview_overlay_options_from_ui()

    def _sync_crop_padding_slider_from_spin(self, slider: QSlider, value: int) -> None:
        self._crop_padding_widget._sync_slider(slider, value)

    def _sync_crop_padding_spin_from_slider(self, spin: QSpinBox, value: int) -> None:
        self._crop_padding_widget._sync_spin(spin, value)

    def _on_crop_settings_changed(self, *_args: Any) -> None:
        """裁切相关选项变更：标记需要全图视图，然后走普通 settings 流程。"""
        self._pending_preview_fit_reset = True
        self._on_output_settings_changed(*_args)

    def _is_placeholder_active(self) -> bool:
        """当前预览是否为占位默认图（不是用户加载的真实照片）。"""
        return self.placeholder_path is not None and self.current_path == self.placeholder_path

    def _on_output_settings_changed(self, *_args: Any) -> None:
        if self.current_path is not None and not self._is_placeholder_active():
            key = _path_key(self.current_path)
            snapshot = self._clone_render_settings(self._build_current_render_settings())
            self.photo_render_overrides[key] = snapshot
            self._update_photo_list_item_display(self.current_path, settings=snapshot)
            self._invalidate_original_mode_cache()
        self._preview_debounce_timer.start()

    def _refresh_crop_padding_fill_swatch(self, *_args: Any) -> None:
        self._crop_padding_widget._refresh_fill_swatch()

    def _set_crop_padding_fill_color(self, color_text: str) -> None:
        self._crop_padding_widget._set_fill_value(color_text)

    def _pick_crop_padding_fill_color(self) -> None:
        self._crop_padding_widget._pick_fill_color()

    def _pick_crop_padding_fill_color_from_screen(self) -> None:
        def _apply(color_hex: str) -> None:
            self._crop_padding_widget._set_fill_value(color_hex)

        _start_screen_color_picker(parent=self, on_picked=_apply)

    def _start_bird_detector_preload(self) -> None:
        if self._bird_detector_preload_started:
            return
        self._bird_detector_preload_started = True

        def _worker() -> None:
            _load_bird_detector()

        thread = threading.Thread(
            target=_worker,
            name="birdstamp-bird-detector-preload",
            daemon=True,
        )
        self._bird_detector_preload_thread = thread
        thread.start()











    def _reload_template_combo(self, preferred: str | None) -> None:
        _ensure_template_repository(self.template_dir)
        names = _list_template_names(self.template_dir)
        self.template_paths = {name: self.template_dir / f"{name}.json" for name in names}

        self.template_combo.blockSignals(True)
        self.template_combo.clear()
        self.template_combo.addItems(names)
        self.template_combo.blockSignals(False)

        if not names:
            self.current_template_payload = _default_template_payload(name="default")
            return

        selected = preferred if preferred in self.template_paths else names[0]
        self.template_combo.setCurrentText(selected)
        self._load_selected_template(selected)
        self._apply_template_ratio_to_main_output()
        self._apply_template_output_settings_to_main_output()
        self._apply_template_crop_padding_to_main_output()

    def _load_selected_template(self, name: str) -> None:
        path = self.template_paths.get(name)
        if not path:
            return
        try:
            self.current_template_payload = _load_template_payload(path)
        except Exception as exc:
            self._show_error("模板错误", str(exc))
            self.current_template_payload = _default_template_payload(name="default")

    def _apply_template_ratio_to_main_output(self) -> None:
        ratio = _parse_ratio_value(self.current_template_payload.get("ratio"))
        idx = self._ratio_combo_index_for_value(ratio)
        if idx < 0:
            return
        self.ratio_combo.blockSignals(True)
        try:
            self.ratio_combo.setCurrentIndex(idx)
        finally:
            self.ratio_combo.blockSignals(False)

    def _reset_template_overrides(self) -> None:
        """将模板选项重载区的所有选项恢复为当前模板中存储的值。"""
        self._apply_template_ratio_to_main_output()
        self._apply_template_output_settings_to_main_output()
        self._apply_template_crop_padding_to_main_output()
        self._invalidate_original_mode_cache()
        self._pending_preview_fit_reset = True
        if self.current_path:
            self._on_output_settings_changed()
        else:
            self.render_preview()

    def _apply_template_crop_padding_to_main_output(self) -> None:
        p = self.current_template_payload
        self._crop_padding_widget.set_values(
            top=_parse_padding_value(p.get("crop_padding_top", _DEFAULT_CROP_PADDING_PX), _DEFAULT_CROP_PADDING_PX),
            bottom=_parse_padding_value(p.get("crop_padding_bottom", _DEFAULT_CROP_PADDING_PX), _DEFAULT_CROP_PADDING_PX),
            left=_parse_padding_value(p.get("crop_padding_left", _DEFAULT_CROP_PADDING_PX), _DEFAULT_CROP_PADDING_PX),
            right=_parse_padding_value(p.get("crop_padding_right", _DEFAULT_CROP_PADDING_PX), _DEFAULT_CROP_PADDING_PX),
            fill=_safe_color(str(p.get("crop_padding_fill", "#FFFFFF")), "#FFFFFF"),
        )

    def _apply_template_output_settings_to_main_output(self) -> None:
        """将模板中的裁切策略 / 裁切中心 / 最大长边应用到主界面控件。"""
        p = self.current_template_payload

        center = _normalize_center_mode(p.get("center_mode", _DEFAULT_TEMPLATE_CENTER_MODE))
        center_idx = self.center_mode_combo.findData(center)
        if center_idx >= 0:
            self.center_mode_combo.blockSignals(True)
            try:
                self.center_mode_combo.setCurrentIndex(center_idx)
            finally:
                self.center_mode_combo.blockSignals(False)

        try:
            max_edge = max(0, int(p.get("max_long_edge") or _DEFAULT_TEMPLATE_MAX_LONG_EDGE))
        except Exception:
            max_edge = _DEFAULT_TEMPLATE_MAX_LONG_EDGE
        max_edge_idx = self._ensure_max_edge_option(max_edge)
        if max_edge_idx >= 0:
            self.max_edge_combo.blockSignals(True)
            try:
                self.max_edge_combo.setCurrentIndex(max_edge_idx)
            finally:
                self.max_edge_combo.blockSignals(False)

    def _on_template_changed(self, name: str) -> None:
        if not name:
            return
        self._load_selected_template(name)
        self._apply_template_ratio_to_main_output()
        self._apply_template_output_settings_to_main_output()
        self._apply_template_crop_padding_to_main_output()
        self._invalidate_original_mode_cache()
        if self.current_path:
            self._on_output_settings_changed()
        else:
            self.render_preview()

    def _open_template_manager(self) -> None:
        from app_common.log import get_logger
        from app_common.stat import stat_begin, stat_end, stat_report, stat_reset

        log = get_logger("template_manager")
        log.info("opening template manager dialog")
        stat_reset()
        stat_begin("template_manager_open")
        dialog = TemplateManagerDialog(template_dir=self.template_dir, placeholder=self.placeholder, parent=self)
        stat_end("template_manager_open")
        for line in stat_report(return_lines=True) or []:
            log.info(line)
        dialog.showMaximized()
        dialog.exec()
        preferred = dialog.current_template_name
        self._reload_template_combo(preferred=preferred)
        if self.current_path:
            settings = self._render_settings_for_path(self.current_path, prefer_current_ui=False)
            self._apply_render_settings_to_ui(settings)
            self.render_preview()

    def _pick_files(self) -> None:
        ext_pattern = " ".join(f"*{ext}" for ext in sorted(SUPPORTED_EXTENSIONS))
        file_paths, _ = QFileDialog.getOpenFileNames(
            self,
            "添加照片",
            "",
            f"Images ({ext_pattern});;All Files (*.*)",
        )
        if not file_paths:
            return
        self._add_photo_paths([Path(item) for item in file_paths])

    def _pick_directory(self) -> None:
        folder = QFileDialog.getExistingDirectory(self, "选择目录", "")
        if not folder:
            return
        found = discover_inputs(Path(folder), recursive=True)
        if not found:
            QMessageBox.information(self, "添加目录", "目录中没有支持的图片文件")
            return
        self._add_photo_paths(found)

    def _format_ratio_display(self, ratio: float | None) -> str:
        parsed = _parse_ratio_value(ratio)
        if parsed is None:
            return "原比例"
        idx = self._ratio_combo_index_for_value(parsed)
        if idx >= 0:
            label = str(self.ratio_combo.itemText(idx) or "").strip()
            if label:
                return label
        text = f"{parsed:.4f}".rstrip("0").rstrip(".")
        return text or "原比例"

    def _parse_display_capture_datetime(self, value: Any) -> datetime | None:
        if value is None:
            return None
        if isinstance(value, datetime):
            return value
        if isinstance(value, (list, tuple)):
            for item in value:
                parsed = self._parse_display_capture_datetime(item)
                if parsed is not None:
                    return parsed
            return None
        if isinstance(value, dict):
            for item in value.values():
                parsed = self._parse_display_capture_datetime(item)
                if parsed is not None:
                    return parsed
            return None

        text = _clean_text(value) or str(value).strip()
        if not text:
            return None
        normalized = text.replace("T", " ").strip()
        if "." in normalized:
            normalized = normalized.split(".", 1)[0]
        for pattern in (
            "%Y:%m:%d %H:%M:%S%z",
            "%Y:%m:%d %H:%M:%S",
            "%Y-%m-%d %H:%M:%S%z",
            "%Y-%m-%d %H:%M:%S",
            "%Y-%m-%d %H:%M",
        ):
            try:
                return datetime.strptime(normalized, pattern)
            except ValueError:
                continue
        try:
            return datetime.fromisoformat(text)
        except Exception:
            return None

    def _photo_info_for_display(
        self,
        path: Path,
        *,
        raw_metadata: dict[str, Any] | None = None,
    ) -> _template_context.PhotoInfo:
        item = self._find_photo_item_by_path(path)
        existing = item.data(PHOTO_COL_ROW, PHOTO_LIST_PHOTO_INFO_ROLE) if item is not None else None
        metadata = raw_metadata if isinstance(raw_metadata, dict) else self._load_raw_metadata(path)
        photo_info = _template_context.ensure_photo_info(
            existing if isinstance(existing, _template_context.PhotoInfo) else path,
            raw_metadata=metadata,
        )
        if item is not None:
            item.setData(PHOTO_COL_ROW, PHOTO_LIST_PHOTO_INFO_ROLE, photo_info)
        return photo_info

    def _provider_text_candidates(
        self,
        photo_info: _template_context.PhotoInfo,
        candidates: Iterable[str],
    ) -> str:
        for source_key in candidates:
            provider = _template_context.build_template_context_provider(
                _template_context.TEMPLATE_SOURCE_AUTO,
                source_key,
            )
            text = str(provider.get_text_content(photo_info) or "").strip()
            if text:
                return text
        return ""

    def _display_filename_from_photo_info(self, photo_info: _template_context.PhotoInfo) -> str:
        return self._provider_text_candidates(
            photo_info,
            ["{filename}"],
        )

    def _extract_display_capture_time_from_metadata(
        self,
        photo_info: _template_context.PhotoInfo,
    ) -> tuple[str, tuple[int, float]]:
        capture_text = self._provider_text_candidates(
            photo_info,
            [
                "capture_text",
                "{capture_text}",
                "capture_date",
                "{capture_date}",
                "EXIF:DateTimeOriginal",
                "ExifIFD:DateTimeOriginal",
                "XMP-exif:DateTimeOriginal",
                "DateTimeOriginal",
                "EXIF:CreateDate",
                "XMP-xmp:CreateDate",
                "CreateDate",
                "DateTimeCreated",
                "DateCreated",
                "MediaCreateDate",
            ],
        )
        capture_dt = self._parse_display_capture_datetime(capture_text)
        if capture_dt is not None:
            try:
                sort_value = float(capture_dt.timestamp())
            except Exception:
                sort_value = 0.0
            return capture_dt.strftime("%Y-%m-%d %H:%M:%S"), (0, sort_value)
        return "-", (1, 0.0)

    def _extract_display_title_from_metadata(self, photo_info: _template_context.PhotoInfo) -> str:
        return self._provider_text_candidates(
            photo_info,
            [
                "bird_species_cn",
                "{bird_common}",
                "{bird}",
                "bird",
                "XMP:Title",
                "XMP-dc:Title",
                "IPTC:ObjectName",
                "IPTC:Headline",
                "EXIF:ImageDescription",
                "EXIF:XPTitle",
                "Image:Title",
                "Title",
                "ImageDescription",
            ],
        )

    def _extract_display_rating_from_metadata(self, photo_info: _template_context.PhotoInfo) -> int | None:
        def _value_to_rating(value: Any) -> int | None:
            if value is None:
                return None
            if isinstance(value, (list, tuple)):
                for item in value:
                    parsed = _value_to_rating(item)
                    if parsed is not None:
                        return parsed
                return None
            if isinstance(value, dict):
                for item in value.values():
                    parsed = _value_to_rating(item)
                    if parsed is not None:
                        return parsed
                return None

            text = _clean_text(value)
            if text:
                full_star_count = text.count("★")
                if full_star_count > 0:
                    return max(0, min(5, full_star_count))
            else:
                text = str(value).strip()

            number_match = re.search(r"[-+]?\d+(?:\.\d+)?", text)
            if not number_match:
                return None
            try:
                raw_score = float(number_match.group(0))
            except Exception:
                return None
            if raw_score < 0:
                return None
            if raw_score > 5:
                raw_score = raw_score / 20.0
            score = int(round(raw_score))
            return max(0, min(5, score))

        rating_text = self._provider_text_candidates(
            photo_info,
            [
                "rating",
                "XMP:Rating",
                "XMP-xmp:Rating",
                "EXIF:Rating",
                "Composite:Rating",
                "Rating",
            ],
        )
        parsed = _value_to_rating(rating_text)
        if parsed is not None:
            return parsed

        for key, value in (_template_context.ensure_photo_info(photo_info).raw_metadata or {}).items():
            key_text = str(key or "").strip().lower()
            if "rating" not in key_text:
                continue
            parsed = _value_to_rating(value)
            if parsed is not None:
                return parsed
        return None

    def _format_rating_display(self, rating: int | None) -> str:
        if rating is None:
            return "-"
        stars = max(0, min(5, int(rating)))
        if stars <= 0:
            return "-"
        return "★" * stars

    def _next_photo_sequence_value(self) -> int:
        next_value = 1
        for idx in range(self.photo_list.topLevelItemCount()):
            item = self.photo_list.topLevelItem(idx)
            if item is None:
                continue
            raw_value = item.data(PHOTO_COL_ROW, PHOTO_LIST_SEQUENCE_ROLE)
            try:
                candidate = int(raw_value)
            except Exception:
                continue
            next_value = max(next_value, candidate + 1)
        return next_value

    def _find_photo_item_by_path(self, path: Path) -> QTreeWidgetItem | None:
        key = _path_key(path)
        for idx in range(self.photo_list.topLevelItemCount()):
            item = self.photo_list.topLevelItem(idx)
            if item is None:
                continue
            raw = item.data(PHOTO_COL_ROW, PHOTO_LIST_PATH_ROLE)
            if isinstance(raw, str) and _path_key(Path(raw)) == key:
                return item
        return None

    def _update_photo_list_item_display(
        self,
        path: Path,
        *,
        raw_metadata: dict[str, Any] | None = None,
        settings: dict[str, Any] | None = None,
    ) -> None:
        item = self._find_photo_item_by_path(path)
        if item is None:
            return

        metadata = raw_metadata if isinstance(raw_metadata, dict) else self._load_raw_metadata(path)
        photo_info = self._photo_info_for_display(path, raw_metadata=metadata)
        filename_text = self._display_filename_from_photo_info(photo_info) or path.name
        capture_time_text, capture_time_sort = self._extract_display_capture_time_from_metadata(photo_info)
        title = self._extract_display_title_from_metadata(photo_info)
        rating_value = self._extract_display_rating_from_metadata(photo_info)
        rating_text = self._format_rating_display(rating_value)
        active_settings = (
            settings
            if isinstance(settings, dict)
            else self._render_settings_for_path(path, prefer_current_ui=False)
        )
        ratio_value = _parse_ratio_value(active_settings.get("ratio"))
        ratio_text = self._format_ratio_display(ratio_value)

        item.setText(PHOTO_COL_NAME, filename_text)
        item.setText(PHOTO_COL_CAPTURE_TIME, capture_time_text)
        item.setText(PHOTO_COL_TITLE, title or "-")
        item.setText(PHOTO_COL_RATIO, ratio_text)
        item.setText(PHOTO_COL_RATING, rating_text)
        item.setToolTip(PHOTO_COL_NAME, str(path))
        item.setToolTip(PHOTO_COL_CAPTURE_TIME, capture_time_text if capture_time_text != "-" else "")
        item.setToolTip(PHOTO_COL_TITLE, title or "")
        item.setToolTip(PHOTO_COL_RATIO, ratio_text)
        item.setToolTip(PHOTO_COL_RATING, rating_text)
        item.setTextAlignment(PHOTO_COL_CAPTURE_TIME, int(Qt.AlignmentFlag.AlignCenter))
        item.setTextAlignment(PHOTO_COL_RATIO, int(Qt.AlignmentFlag.AlignCenter))
        item.setTextAlignment(PHOTO_COL_RATING, int(Qt.AlignmentFlag.AlignCenter))
        item.setData(PHOTO_COL_NAME, PHOTO_LIST_SORT_ROLE, (0, filename_text.casefold()))
        item.setData(PHOTO_COL_CAPTURE_TIME, PHOTO_LIST_SORT_ROLE, capture_time_sort)
        item.setData(PHOTO_COL_TITLE, PHOTO_LIST_SORT_ROLE, (0, title.casefold()) if title else (1, ""))
        item.setData(
            PHOTO_COL_RATIO,
            PHOTO_LIST_SORT_ROLE,
            (0, float(ratio_value)) if ratio_value is not None else (1, 0.0),
        )
        item.setData(
            PHOTO_COL_RATING,
            PHOTO_LIST_SORT_ROLE,
            (0, int(rating_value)) if rating_value is not None else (1, 0),
        )
        self.photo_list.resort()

    def _list_photo_paths(self) -> list[Path]:
        paths: list[Path] = []
        for idx in range(self.photo_list.topLevelItemCount()):
            item = self.photo_list.topLevelItem(idx)
            if not item:
                continue
            raw = item.data(PHOTO_COL_ROW, PHOTO_LIST_PATH_ROLE)
            if isinstance(raw, str):
                paths.append(Path(raw))
        return paths

    def _add_photo_paths(self, paths: Iterable[Path]) -> None:
        valid_paths: list[Path] = []
        for incoming in paths:
            try:
                path = incoming if isinstance(incoming, Path) else Path(str(incoming))
                path = path.resolve(strict=False)
            except Exception:
                continue
            if not path.is_file() or path.suffix.lower() not in SUPPORTED_EXTENSIONS:
                continue
            valid_paths.append(path)

        auto_added_report_db_count = self._auto_add_report_db_paths_for_photos(valid_paths)

        existing_keys = {_path_key(path) for path in self._list_photo_paths()}
        default_settings = self._build_current_render_settings()
        add_count = 0

        for path in valid_paths:
            key = _path_key(path)
            if key in existing_keys:
                continue
            existing_keys.add(key)

            current_settings = self._clone_render_settings(default_settings)
            self.photo_render_overrides[key] = current_settings
            raw_metadata = self._load_raw_metadata(path)
            photo_info = _template_context.ensure_photo_info(path, raw_metadata=raw_metadata)
            item = PhotoListItem(["", "", "", "", "", "", ""])
            sequence_value = self._next_photo_sequence_value()
            item.setData(PHOTO_COL_ROW, PHOTO_LIST_PATH_ROLE, str(path))
            item.setData(PHOTO_COL_ROW, PHOTO_LIST_PHOTO_INFO_ROLE, photo_info)
            item.setData(PHOTO_COL_ROW, PHOTO_LIST_SEQUENCE_ROLE, sequence_value)
            item.setData(PHOTO_COL_ROW, PHOTO_LIST_SORT_ROLE, (0, sequence_value))
            item.setToolTip(PHOTO_COL_ROW, "")
            item.setTextAlignment(PHOTO_COL_ROW, int(Qt.AlignmentFlag.AlignCenter))
            self.photo_list.addTopLevelItem(item)
            self._update_photo_list_item_display(path, raw_metadata=raw_metadata, settings=current_settings)
            add_count += 1

        if add_count == 0 and auto_added_report_db_count == 0:
            self._set_status("没有新增照片。")
            return

        if self.photo_list.currentItem() is None and self.photo_list.topLevelItemCount() > 0:
            first_item = self.photo_list.topLevelItem(0)
            if first_item is not None:
                self.photo_list.setCurrentItem(first_item)

        self.photo_list.refresh_row_numbers()

        if add_count > 0 and auto_added_report_db_count > 0:
            self._set_status(f"已添加 {add_count} 张照片，并自动添加 {auto_added_report_db_count} 个 report.db。")
            return
        if add_count > 0:
            self._set_status(f"已添加 {add_count} 张照片。")
            return
        self._set_status(f"没有新增照片，已自动添加 {auto_added_report_db_count} 个 report.db。")

    def add_received_file_paths(self, paths: list[str]) -> None:
        """
        由「发送到本应用」热接收回调调用，将接收到的文件路径加入照片列表。
        可在任意线程调用；内部通过 QTimer.singleShot 投递到主线程执行。
        """
        if not paths:
            return
        _log.info("send_to_app: received %d file(s), scheduling add to photo list: %s", len(paths), paths)
        path_objs = [Path(p) for p in paths]
        QTimer.singleShot(0, lambda: self._add_photo_paths(path_objs))

    def _remove_selected_photos(self) -> None:
        selected_items = self.photo_list.selectedItems()
        if not selected_items:
            return

        removed_keys: list[str] = []
        for item in selected_items:
            raw = item.data(PHOTO_COL_ROW, PHOTO_LIST_PATH_ROLE)
            if isinstance(raw, str):
                removed_keys.append(_path_key(Path(raw)))
            row = self.photo_list.indexOfTopLevelItem(item)
            if row >= 0:
                self.photo_list.takeTopLevelItem(row)

        for key in removed_keys:
            self.raw_metadata_cache.pop(key, None)
            self.photo_render_overrides.pop(key, None)
        if removed_keys:
            self._bird_box_cache.clear()
            self.photo_list.refresh_row_numbers()

        if self.photo_list.topLevelItemCount() == 0:
            self.placeholder_path = None
            self.current_path = None
            self.current_photo_info = None
            self.current_source_image = None
            self.current_raw_metadata = {}
            self.current_metadata_context = {}
            self.current_file_label.setText("当前照片: 未选择")
            self.last_rendered = None
            self._show_placeholder_preview()

        self._set_status(f"已删除 {len(selected_items)} 项。")

    def _clear_photos(self) -> None:
        self.photo_list.clear()
        self.raw_metadata_cache.clear()
        self.photo_render_overrides.clear()
        self._bird_box_cache.clear()
        self.placeholder_path = None
        self.current_path = None
        self.current_photo_info = None
        self.current_source_image = None
        self.current_raw_metadata = {}
        self.current_metadata_context = {}
        self.current_file_label.setText("当前照片: 未选择")
        self.last_rendered = None
        self._show_placeholder_preview()
        self._set_status("已清空照片列表。")

    def _on_photo_selected(self, current: QTreeWidgetItem | None, _previous: QTreeWidgetItem | None) -> None:
        if not current:
            return
        raw = current.data(PHOTO_COL_ROW, PHOTO_LIST_PATH_ROLE)
        if not isinstance(raw, str):
            return
        path = Path(raw)
        if not path.exists():
            self._show_error("文件不存在", str(path))
            return

        try:
            image = decode_image(path, decoder="auto")
        except Exception as exc:
            self._show_error("读取失败", str(exc))
            return

        self.placeholder_path = None
        self.current_path = path
        self.current_source_image = image
        self._invalidate_original_mode_cache()
        self.current_raw_metadata = self._load_raw_metadata(path)
        photo_info = current.data(PHOTO_COL_ROW, PHOTO_LIST_PHOTO_INFO_ROLE)
        self.current_photo_info = _template_context.ensure_photo_info(
            photo_info if isinstance(photo_info, _template_context.PhotoInfo) else path,
            raw_metadata=self.current_raw_metadata,
        )
        current.setData(PHOTO_COL_ROW, PHOTO_LIST_PHOTO_INFO_ROLE, self.current_photo_info)
        self.current_metadata_context = _build_metadata_context(self.current_photo_info, self.current_raw_metadata)
        settings = self._render_settings_for_path(path, prefer_current_ui=False)
        self._apply_render_settings_to_ui(settings)
        self._update_photo_list_item_display(path, raw_metadata=self.current_raw_metadata, settings=settings)
        self.current_file_label.setText(f"当前照片: {path}")
        self.render_preview()

    def _load_raw_metadata(self, path: Path) -> dict[str, Any]:
        key = _path_key(path)
        if key in self.raw_metadata_cache:
            return self.raw_metadata_cache[key]

        resolved = path.resolve(strict=False)
        raw_metadata: dict[str, Any]
        try:
            raw_metadata = extract_metadata_with_xmp_priority(resolved, mode="auto")
        except Exception:
            try:
                raw_map = extract_many([resolved], mode="auto")
                raw_metadata = raw_map.get(resolved) or extract_pillow_metadata(path)
            except Exception:
                raw_metadata = extract_pillow_metadata(path)
        if not isinstance(raw_metadata, dict):
            raw_metadata = {"SourceFile": str(path)}

        # 通过 app_common.exif_io 统一读取文件列表依赖的 XMP/sidecar 字段（Title/Rating/Pick 等）。
        # 放在最后合并，确保列表显示与 Banner 模板字段优先使用 exif_io 的 XMP 结果。
        try:
            batch_map = read_batch_metadata([str(resolved)])
        except Exception:
            batch_map = {}
        if isinstance(batch_map, dict) and batch_map:
            try:
                batch_metadata = next(iter(batch_map.values()))
            except Exception:
                batch_metadata = None
            if isinstance(batch_metadata, dict):
                merged = dict(raw_metadata)
                merged.update(batch_metadata)
                raw_metadata = merged

        self.raw_metadata_cache[key] = raw_metadata
        return raw_metadata










    def _selected_photo_paths(self) -> list[Path]:
        selected_items = self.photo_list.selectedItems()
        paths: list[Path] = []
        if selected_items:
            for item in selected_items:
                raw = item.data(PHOTO_COL_ROW, PHOTO_LIST_PATH_ROLE)
                if isinstance(raw, str):
                    paths.append(Path(raw))
        elif self.current_path is not None and not self._is_placeholder_active():
            paths.append(self.current_path)

        ordered: list[Path] = []
        seen: set[str] = set()
        for path in paths:
            key = _path_key(path)
            if key in seen:
                continue
            seen.add(key)
            ordered.append(path)
        return ordered

    def _apply_current_settings_to_selected_photos(self) -> None:
        targets = self._selected_photo_paths()
        if not targets:
            self._set_status("请先选择要应用设置的照片。")
            return

        snapshot = self._build_current_render_settings()
        for path in targets:
            normalized = self._clone_render_settings(snapshot)
            self.photo_render_overrides[_path_key(path)] = normalized
            self._update_photo_list_item_display(path, settings=normalized)

        if self.current_path is not None:
            current_key = _path_key(self.current_path)
            if any(_path_key(path) == current_key for path in targets):
                self.render_preview()

        self._set_status(f"已将当前裁切重载设置应用到 {len(targets)} 张照片。")

    def _apply_current_settings_to_all_photos(self) -> None:
        targets = self._list_photo_paths()
        if not targets:
            self._set_status("照片列表为空。")
            return

        snapshot = self._build_current_render_settings()
        for path in targets:
            normalized = self._clone_render_settings(snapshot)
            self.photo_render_overrides[_path_key(path)] = normalized
            self._update_photo_list_item_display(path, settings=normalized)

        if self.current_path is not None:
            self.render_preview()
        self._set_status(f"已将当前裁切重载设置应用到全部 {len(targets)} 张照片。")


def launch_gui(
    startup_file: Path | None = None,
    startup_files: list[Path] | None = None,
) -> None:
    _log.info(
        "launch_gui enter startup_file=%s startup_files=%s",
        str(startup_file) if startup_file else "",
        [str(path) for path in (startup_files or [])],
    )
    app = QApplication.instance() or QApplication(sys.argv)
    window = BirdStampEditorWindow(startup_file=startup_file, startup_files=startup_files)
    _log.info("editor window created")
    window.showMaximized()
    _log.info("editor window shown")

    # 热接收：单例 IPC，其它进程通过 send_file_list_to_running_app 发来文件列表时加入本窗口照片列表
    def on_files_received(paths: list[str]) -> None:
        _log.info("received files from running instance count=%s", len(paths))
        window.add_received_file_paths(paths)

    receiver = SingleInstanceReceiver(SEND_TO_APP_ID, on_files_received)
    if receiver.start():
        window._send_to_app_receiver = receiver  # 保持引用，避免被回收；退出时可选 stop()
        _log.info("single instance receiver started")
    else:
        window._send_to_app_receiver = None
        _log.info("single instance receiver unavailable")

    def _on_about_to_quit() -> None:
        _log.info("qt aboutToQuit emitted")
        active_receiver = getattr(window, "_send_to_app_receiver", None)
        if active_receiver is not None:
            try:
                active_receiver.stop()
            except Exception as exc:
                _log.warning("receiver stop failed: %s", exc)

    app.aboutToQuit.connect(_on_about_to_quit)
    exit_code = app.exec()
    _log.info("qt event loop exited code=%s window_visible=%s", exit_code, window.isVisible())
